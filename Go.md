# 环境准备

？ 

echo

gin

`go version`查看安装结果

GOPATH，go的工作目录

GOROOT，SDK安装目录

* GoProxy



项目目录结构：GOPATH/src/项目/package



package表示该文件归属于哪个包



**优点**

* 提供海量的并行支持，适合高性能分布式服务



# 变量



**变量声明**

Go声明变量时变量在前，类型在后

`var 变量名 类型`

可以将若干声明放在一起(注意格式)，这种因式分解关键字的写法一般用于声明全局变量

```go
var (
	name string
    age int
)
```

可以一次声明多个类型一样的变量

```go
var 变量[,变量1] 类型
```

声明变量时就初始化的，变量的类型不用写

```go
var age = 18
```

变量声明但未使用会报错



**变量初始化**

声明变量的时候进行初始化，var就是非必须的，类型也可以自动推导出来

```go
var v1 int = 10 // 正确的使用方式1
var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型
v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型
```

**:=用来明确表名同时进行声明和初始化**，一个变量只能初始化一个，执行多次:=会报错



**变量赋值**

Go提供了多重赋值功能

```go
i,j := 1,2
i, j = j, i 
```



匿名变量

在调用函数时为了获取一个 值，却因为该函数返回多个值而不得不定义一堆没用的变量时，其他变量不用声明，用`_`表示。



**常量**





**常量的定义**

通过const关键字定义`const name type = value`

常量的类型是非必须的可以推断出来。

常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值.

常量赋值是编译期的行为，所以不能赋运行期才知道的结果。

可以一次声明多个常量

```go
const name1, name2 = value1, value2
const(
	name1 = value1
    name2
)
```

**在常量声明中，如果一个常量没有赋值，则他就跟上一行的赋值相同** 

###  

**字面常量**

就是硬编码的常量。Go的字面常量是无类型的，-12可以给int，uint，int32，float等



**预定义常量**

Go语言预定义了这些常量：true、false和iota

**iota**

iota是一个特殊的常量，可以当成是一个可以被编译器修改的常量.iota第一次出现时的值为0， 在const中每新增一行将使得iota计数一次 ，

```go
const ( // iota被重设为0
 c0 = iota // c0 == 0
 c1 = iota // c1 == 1
 c2 = iota // c2 == 2
)
const (
 a = 1 << iota // a == 1 (iota在每个const开头被重设为0)
 b = 1 << iota // b == 2
 c = 1 << iota // c == 4
)
const (
 u = iota * 42 // u == 0
 v float64 = iota * 42 // v == 42.0 
 w = iota * 42 // w == 84
)
const x = iota // x == 0 (因为iota又被重设为0了)
const y = iota // y == 0 (同上)
如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。因此，上
面的前两个const语句可简写为：
const ( // iota被重设为0
 c0 = iota // c0 == 0
 c1 // c1 == 1
 c2 // c2 == 2
)
const (
 a = 1 <<iota // a == 1 (iota在每个const开头被重设为0)
 b // b == 2
 c // c == 4
) 
```



**枚举**

```go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
```

这种定义法在Go语言中通常用于定义枚举值。



## 数据类型



**布尔类型**

bool



**整型**

int8/16/32/64

uint8/16/32/64

int

uint

uintptr

int和int32在Go语言里被认为是两种不同的类型，编译器也不会帮你自动做类型转换,需要强制类型转换(需要注意长度截断和值溢出的问题)。



**浮点型**

float32等价于C语言的float类型，
float64等价于C语言的double类型

自动推导类型时float64

浮点类型是不精确的，直接用==来判断是不行的。

```go
import "math"
// p为用户自定义的比较精度，比如0.00001
func IsEqual(f1, f2, p float64) bool {
 return math.Fdim(f1, f2) < p
}
```



**复数**



**字符串**

Go中，字符串也是一种基本数据类型。字符串可以当成一个数组，但不能修改数组中的元素。

```go
len(s) // 字符串字节数
s + y // 字符串拼接
s[i]  // 取字符串
fmt.Sprintf() // 格式化字符串
```



**字符类型**

一种是byte(uint8),代表UTF-8字符串中的字符，一种是rune,代表Unicode字符。出于简化语言的考虑，Go语言的多数API都假设字符串为UTF-8编码。尽管Unicode字符在标准库中有支持，但实际上较少使用。



**数组**

声明

```go
[32]byte // 长度为32的数组，每个元素为一个字节
[2*N] struct { x, y int32 } // 复杂类型数组
[1000]*float64 // 指针数组
[3][5]int // 二维数组
[2][2][2]float64 // 等同于[2]([2]([2]float64)) 
```

数组的长度是该数组类型的一个内置常量，可以用Go语言的内置函数len()来获取

遍历数组：

1. 通过下标
2. range

在Go语言中数组是一个值类型， 值类型变量在赋值和作为参数传递是都是复制操作，产生一个副本。



**数组切片**

可动态增减元素是数组切片比数组更为强大的功能。 类似Java的ArrarList?

数组切片的数据结构可以抽象为以下3个变量： 

* 一个指向原生数组的指针
* 数组切片中的元素个数
* 数组切片已分配的存储空间。 

创建数组切片



cap()函数返回的是数组切片分配的空间大小，而len()函数返回的是数组切片中当前所存储的元素个数



可以使用append()在末尾新增元素

```go
mySlice = append(mySlice, 1, 2, 3)
mySlice2 := []int{8, 9, 10}
// 给mySlice后面添加另一个数组切片
mySlice = append(mySlice, mySlice2...)
```



copy()

如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行 复制。 



**map**

声明

```go
var 变量名 map [key类型] value类型
```

创建，通过make

```go
make(map [KeyType] ValueType, 初始容量)
```

赋值



删除

delete()



查找

不用再进行控制判断

```go
value, ok := myMap["1234"]
if ok { // 找到了
 // 处理找到的value
}
```



**struct**



**函数**



**接口**



**值类型和引用类型**

值类型：变量直接指向内存中的值

引用类型：变量存储着值在内存中的地址



## 指针



&取地址

*取指针指向的值



# 流程控制



## 条件判断

**条件语句**

```go
if a < 5 {
 return 0
} else {
 return 1
} 
```

* 条件语句



**选择语句**

* switch后的语句不是必须的，在此种情况下，整个switch结构与多个if...else...的逻辑作用等同



## **循环**

只支持for循环

```go
for condition {
    
}
```



也可以不指定条件**无限循环**

```go
for {
    println("hello")
}
```



**跳转语句**

```go
func myfunc() {
 i := 0
 HERE:
 fmt.Println(i)
 i++
 if i < 10 {
 goto HERE
 }
}
```

跳转到某个标签



# 函数



**定义**

又func关键字、函数名、参数列表、返回值列表、函数体和返回语句构成

```go
func Add(a int, b int) (ret int, err error) {
 if a < 0 || b < 0 { // 假设这个函数只支持两个非负数字的加法
 err= errors.New("Should be non-negative numbers!")
 return
 }
 return a + b, nil // 支持多重返回值
}
```

* 返回值列表中可以返回错误，成功时error返回nil
* 就像函数的输入参数一样。 返回值被命名之后，它们的值在函数开始的时候被自动初始化为空。在函数中执行不带任何参数 的return语句时，会返回对应的返回值变量的值。 
* 参数列表中类型相同的可以只写一个类型，返回值相同
* 返回值只有一个值时，可以省略括号
* 小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用

**不定参数**： 如`...type`格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。

本质是数组切片。

传参时可以传入多个或一个数组切片

任意类型的不定参数 ： 可以指定类型为`...interface{}`









### 匿名函数与闭包

**匿名函数**：不带函数名，函数可以像普通变量一个被传递和使用。

花括号中直接接参数列表或者用变量加参数列表进行调用。



**闭包**：闭包是包含自由变量的代码块。

**闭包的价值**：

只要闭包还被使用，那么被闭包引用的变量会一直存在。

函数的返回值是函数(一个函数中的函数用到了外层函数的变量，外层函数执行完后，应用的变量不会被清理掉)



作用：是能够被函数动态创建和返回 



# 错误处理

漂亮的错误处理规范是Go语言最大的亮点之一



**error接口** 

```go
type error interface {
 Error() string
} 
```



通常将错误作为最后一个返回值返回

```go
n, err := Foo(0)
if err != nil {
 // 错误处理
} else {
 // 使用返回值n
}
```



**自定义error类型**

实现error的Error()方法，就可以当成error来用

```go
type PathError struct {
 Op string
 Path string
 Err error
}    
```

实现Error()方法

```go
func (e *PathError) Error() string {
 return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

抛出自定义的异常

```go
func Stat(name string) (fi FileInfo, err error) {
 var stat syscall.Stat_t
 err = syscall.Stat(name, &stat)
 if err != nil {
 return nil, &PathError{"stat", name, err}
 }
 return fileInfoFromStat(&stat, name), nil
}
```



```
依赖未完成，跳过任务，step:11,taskID:120715
cron时间依赖未开始: task:
```



**defer**

类似finally？， 一个函数中可以存在多个defer语句，延时执行



**panic和recover**

panic打印错误处理流程信息

recover()函数用于终止错误处理流程





# 面向对象编程



？ 

* 给结构体添加方法时，什么时候用指针，什么时候



## **类型系统**

* 基础类型
* 复合类型：数组，结构体，指针等
* 可以指向任何对象的类型(Any，即interface{}空接口)
* 值和引用
* 面向对象， 即所有具备面向对象特征（比如成员方法）的类型 
* 接口

类型系统用来描述这些类型是怎么关联起来的。



**为类型添加方法**

Go语言中，你可以给任意类型（包括内置类型，但不包括指针类型）

```go
type Integer int
func (a Integer) Less(b Integer) bool {
 return a < b
} 
```

*  方法施加的目标（也就是“对象”）显式传递，没有被隐藏起来
*  方法施加的目标（也就是“对象”）不需要非得是指针，也不用非得叫this

```go
func (a *Integer) Add(b Integer) {
 *a += b
} 
```

**只有想修改对象的内容时才需要使用指针**

* 由于Add()方法需要修改对象的值，所以需要用指针引用 



**值语义与引用语义**

Go语言中的大多数类型都基于值语义，包括： 

* 基本类型，如byte、int、bool、float32、float64和string等
* 复合类型，如数组（array）、结构体（struct）和指针（pointer）等



Go语言中有4个类型比较特别，看起来像引用类型:

* 数组切片：指向数组（array）的一个区间
* map：极其常见的数据结构，提供键值查询能力。
* channel：执行体（goroutine）间的通信设施。  接口（interface）：对一组满足某个契约的类型的抽象。 



**结构体**

Go语言的结构体（struct）和其他语言的类（class）有同等的地位，但Go语言放弃了包括继 承在内的大量面向对象特性，只保留了组合（composition）这个最基础的特性。

组合并不是属于面向推向的特点，C也有组合，组合是形成复合类型的基础。

1. 定义结构体

```go
type Rect struct {
 x, y float64
 width, height float64
}
```

2. 然后定义(添加)成员方法

```go
func (r *Rect) Area() float64 {
 return r.width * r.height
} 
```



**创建实例**

通过new或者&创建对象

```go
rect1 := new(Rect)
rect2 := &Rect{}
rect3 := &Rect{0, 0, 100, 200}
rect4 := &Rect{width: 100, height: 200}
```

Go语言中没有构造方法的概念



**组合**

就是定义一个struct时引用另一个struct



**匿名组合**

匿名组合类型相当于以其类型名称（去掉包名部分） 作为成员变量的名字 



**可见性**

可见性只分为包内可见和其他包也可见，通过大小写区分

可见性用首字符大小写区分对当前包有效(小写)还是其他包都有效(大写)。



## 接口

接口是Go语言 整个类型系统的基石。

侵入式接口：其他语言一个类实现了一个接口的所有方法，但是没在类上声明实现接口就不算

非入侵式接口：不用显式指出实现了哪些接口，只需要实现了接口中的所有方法，我们就认为他实现了这个接口。

好处：？ 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理，比如我实现了A，B，C三个方法，有一个接口需要A，一个需要B，一个需要AB，我不用再显示的指明实现的接口，不管你以后怎么定义的接口，只要我有方法，就可以作为你的实现类。



**接口赋值**

* 将对象实例赋值给接口
* 将接口赋值给另一个接口



**接口查询**

即类型判断。对象是否是某个接口

```go
if a, ok :=实例.(接口); ok{
    
}
```





**类型查询**



**接口组合**



**Any类型**



# IO



# 并发编程

goroutine和channel 是支撑起Go语言的并发模型的基石

今集群化与多核化 



协程



**channel**

goroutine之间的通信



# 网络编程





# Go命令行工具



| 命令     | 描述                     |
| -------- | ------------------------ |
| go run   | 编译链接运行             |
| go build | 不运行，只生成可执行文件 |
|          |                          |





GOPATH

* 先框架，后细节

**应用领域**

* 区块链
* 服务器
* 游戏
* 分布式/云计算



**特点**

站在Go的角度想想，为什么这么做



数据处理，高并发， 提供了海量并行的支持。

强制代码风格

不支持函数重载

反对继承，支持组合

放弃了构造函数

接口不再具有侵入性

不得包含在源代码文件中没有用到的包，否则Go编译器会报编译错误。 



* 自动垃圾回收
* 丰富的内置类型(切片)
* 函数多返回值
* 错误处理(减少代码量)
* 匿名函数与闭包
* 类型和接口：实现一个接口之前必须定义一个接口，就扣的修改会影响到所有的实现类。Go在定义接口和实现类时像是完全没有关系，但是在使用时又可以利用接口的关系
* 并发编程： goroutine， 通过在函数调用前使用关键字go，我们即可让该函数以goroutine方式执行。协程，CSP，channel，Unix的管道
* 反射，Go不推荐，
* 语言交互性：Cgo



* 工程管理方法：构建工程GOPATH, Go命令行程序制 定的目录结构规则,







并发执行

```go
func run(arg string) {
 // ...
}
func main() {
 go run("test")
 ...
} 
```



**执行体间的通信**

互斥与同步：访问共享资源和时序

消息传递：共享内存模型，消息传递模型( Erlang )。Go推荐后者，在Go语言中内置了消息队列的支持，只不过它叫通道（channel）。两 个goroutine之间可以通过通道来进行交互。 





xxx_test.go表示的是一个对于xxx.go的单元 测试，这也是Go工程里的命名规则 



# Go代码风格

{}



错误处理规范



要生成Go可执行程序，必须建立一个名 字为main的包，并且在该包中包含一个叫main()的函数， 命令行传入的参数在os.Args变量 中保存



****

函数

```go
func 函数名(参数列表)(返回值列表) {
 // 函数体
} 
```



# 问题追踪与调试

打印日志和GDB进行逐步调试





# import



**flag**





**fmt** 